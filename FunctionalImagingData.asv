classdef FunctionalImagingData < handle
    %FUNCTIONALIMAGINGMATRIX Summary of this class goes here
    %   The object must be created by specifying 2 arguments:
    %   folderPath: string identifying path to the folder containing the raw data
    %   channel: can be either 'green','red','blue' or 'speckle'
    
    properties
        channel %Green, red, blue or speckle
        folderPath %Path to folder containing raw data
        metaDataFile
        nrows
        ncols
        nframes
        freq
        data %data in 3D format (nrows by ncols by nframes) 
    end
    
    methods
        function obj = FunctionalImagingData(folderPath,channel)
            %FUNCTIONALIMAGDATA Construct an instance of this class
            %   Detailed explanation goes here
            obj.channel = channel;
            obj.folderPath = folderPath;
            obj.metaDataFile = matfile([folderPath filesep 'Data_' channel '.mat']);
            obj.nrows = datMatFile.datSize(1,1);
            obj.ncols = datMatFile.datSize(1,2);
            obj.nframes = datMatFile.datLength;
            obj.freq = datMatFile.Freq;
            obj.data = getMovie(obj);
        end
        
        function movie = getMovie(obj)
            %getMovie returns 3D movie matrix (nrows by ncols by nframes)
            mapFile = memmapfile(obj.metaDataFile.datFile,...
                'Format',{'single',[double(obj.nrows) double(obj.ncols) double(obj.nframes)],'img'},'Repeat',1,'Writable',true);
            movie = mapFile.Data.img;
        end
        function matrix = get2DMatrix(obj)
            %get2DMatrix returns 2D data matrix (nframes by npixels)
            mapFile = memmapfile(obj.metaDataFile.datFile,...
                'Format',{'single',[double(obj.nrows) double(obj.ncols) double(obj.nframes)],'img'},'Repeat',1,'Writable',true);
            movie = mapFile.Data.img;
            matrix_perm = permute(threeDimImMatrix,[3 1 2]);
            matrix = reshape(matrix_perm,obj.nframes,obj.nrows*obj.ncols); 
        end
        function matrix = convertToMovie(obj)
            %convertToMovie converts obj.data to a 3D form
            if ndims(obj.data) == 2
                reshapedMatrix = reshape(obj.data,obj.nframes,obj.nrow,obj.ncols);
                movie = permute(reshapedMatrix,[2 3 1]);
                obj.data = movie;
            end
        end
        function matrix = convertTo2DMatrix(obj)
            %convertTo2DMatrix converts obj.data to a 2D form
            if ndims(obj.data) == 3
                matrix_perm = permute(threeDimImMatrix,[3 1 2]);
                matrix = reshape(matrix_perm,obj.nframes,obj.nrows*obj.ncols);
                obj.data = matrix;
            end
        end
        function mask = createMask(obj)
            %createMask creates a user specified 2D mask that can be applied to obj frames
            mask = ROIselect(obj.data(:,:,1));
        end
        function applyMask(obj,mask)
            %applyMask multi
            obj.data = obj.data.*mask;
        end
        function correctMotion(obj)
            %correctMotion corrects motion using dftregistration algorithm. 
            if Registration
                if i == 1
                    [mvmtcorrFrames,rect] = Crop(Green_indResponse); %identify region to use for motion correction computations
                else
                    mvmtcorrFrames = Crop(Green_indResponse,rect);
                end
                ref = mvmtcorrFrames(:,:,1); %reference frame for motion correction
                usfac = 1; %precision level for dftregistration function
                for j = 1:size(mvmtcorrFrames,3)
                    output = dftregistration(fft2(ref),fft2(mvmtcorrFrames(:,:,j)),usfac);
                    tx = output(4); %Keep movement variables in array for possible future use in GLM
                    ty = output(3);
                    Green_indResponse(:,:,j) = imtranslate(Green_indResponse(:,:,j),[tx,ty],'OutputView','same','method','bicubic');
                end
            end
end

